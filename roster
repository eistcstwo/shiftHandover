import xlrd
import pandas as pd
import numpy as np
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import Roster, Attendance, RosterAnnotation
import datetime
import io
import re
from difflib import SequenceMatcher
from django.db.models import Q
from django.http import JsonResponse
from awthenticationService.views import decode_jwt_token_api

def to_safe_time(t):
    if pd.isna(t) or t is None:
        return None
    if isinstance(t, datetime.time):
        return t
    if isinstance(t, (float, int)):
        total_seconds = int(t * 24 * 60 * 60)
        total_seconds = min(total_seconds, 86399)
        hours, remainder = divmod(total_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        return datetime.time(hours, minutes, seconds)
    try:
        return pd.to_datetime(str(t), errors='coerce').time()
    except (ValueError, TypeError):
        return None

def robust_date_parser(date_val, year, month):
    if pd.isna(date_val):
        return None

    date_str = str(date_val).strip()
    try:
        dt = pd.to_datetime(date_str, dayfirst=True, errors='raise')
        if dt.year == year and dt.month == month:
            return dt.date()
    except ValueError:
        pass

    try:
        parts = [int(p) for p in re.split(r'[/\-.]', date_str) if p.isdigit()]

        if len(parts) == 3:
            if year in parts: parts.remove(year)
            if month in parts: parts.remove(month)

            if len(parts) == 1 and 1 <= parts[0] <= 31:
                return datetime.date(year, month, parts[0])

        elif len(parts) == 2:
            p1, p2 = parts[0], parts[1]
            if p1 == month and 1 <= p2 <= 31:
                return datetime.date(year, month, p2)
            if p2 == month and 1 <= p1 <= 31:
                return datetime.date(year, month, p1)

    except (ValueError, TypeError, IndexError):

        return None

    return None

def validate_auth(request):
    token = request.headers.get("Authorization")
    if not token:
       return JsonResponse({"message": "Session unautherize"}, status=401, safe=False)

    try:
        sessionStatus = decode_jwt_token_api(token)
        if not sessionStatus:
            return JsonResponse({"message": "Session unautherize"}, status=401, safe=False)
    except Exception as e:
        return JsonResponse({"message": "user unauthorized"}, status=401, safe=False)

    return None

class FileUploadView(APIView):
    def post(self, request, *args, **kwargs):
        auth_error = validate_auth(request)
        if auth_error:
            return auth_error
        roster_file = request.FILES.get('roster')
        attendance_file = request.FILES.get('attendance_sheet_1')
        if not roster_file or not attendance_file:
            return Response(
                {'error': 'Please upload both "roster" and "attendance" files.'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            roster_engine = 'xlrd' if roster_file.name.lower().endswith('.xls') else 'openpyxl'
            roster_df = pd.read_excel(io.BytesIO(roster_file.read()), header=0, skiprows=[1], engine=roster_engine)
            roster_df.columns = [str(c).strip().lower() for c in roster_df.columns]
            roster_df['sr no'] = roster_df['sr no'].fillna(method='ffill')
            attendance_engine = 'xlrd' if attendance_file.name.lower().endswith('.xls') else 'openpyxl'
            attendance_df = pd.read_excel(io.BytesIO(attendance_file.read()), header=None, skiprows=1, usecols=range(13), engine=attendance_engine)
            attendance_df.columns = [
                'ads_id', 'name_in_attendance', 'user_type', 'designation', 'department',
                'location', 'first_in', 'last_out', 'gross_time', 'out_of_office_time',
                'out_of_office_count', 'net_office_time', 'attendance_date'
            ]

            temp_dates = pd.to_datetime(attendance_df['attendance_date'], dayfirst=True, errors='coerce')
            valid_dates = temp_dates.dropna()

            if valid_dates.empty:
                return Response(
                    {'error':'Could not find valid dates in attendance file,'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            mode_date = valid_dates.mode()[0]
            processing_year, processing_month = mode_date.year, mode_date.month

            attendance_df['parsed_date'] = attendance_df['attendance_date'].apply(
                lambda x: robust_date_parser(x, processing_year, processing_month)
            )

            roster_names = roster_df['name'].dropna().unique().tolist()
            attendance_names = attendance_df['name_in_attendance'].dropna().unique().tolist()

            print("\n--- Starting Name Matching Process ---")
            name_map = {}
            for att_name in attendance_names:
                best_match_name = None
                highest_score = 0
                att_name_lower = att_name.lower()
                att_tokens = set(att_name_lower.split())

                for roster_name in roster_names:
                    roster_name_lower = roster_name.lower()
                    roster_tokens = set(roster_name_lower.split())

                    if roster_tokens.issubset(att_tokens) or att_tokens.issubset(roster_tokens):
                        score = 0.95
                    else:
                        score = SequenceMatcher(None, att_name_lower, roster_name_lower).ratio()

                    if score > highest_score:
                        highest_score = score
                        best_match_name = roster_name

                print(f"--> For Attendance Name: '{att_name}'")
                print(f"    Best Roster Match: '{best_match_name}' with score {highest_score:.2f}")

                if highest_score >= 0.8:
                    name_map[att_name] = best_match_name
                    print(f"   *** Match ACCEPTED ***\n")
                else:
                    print(f"   --- Match REJECTED (score below 0.8) ---\n")
            print("--- name matching process finished ---\n")

            attendance_df['name'] = attendance_df['name_in_attendance'].map(name_map)
            matched_names = list(name_map.values())
            roster_df = roster_df[roster_df['name'].isin(matched_names)]

            attendance_df = attendance_df.dropna(subset=['name', 'parsed_date'])

            self._process_roster_data(roster_df, processing_year, processing_month)
            self._process_attendance_data(attendance_df)

        except Exception as e:
            return Response({'error': f'Please convert the excelsheet to xlsx file format and reupload!'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        return Response(
            {'message': f'Files processed successfully for {mode_date.strftime("%B %Y")}. Only matched records were saved.'},
            status=status.HTTP_201_CREATED
        )


    def _process_roster_data(self, df, year, month):
        for _, row in df.iterrows():
            name = row.get('name')
            team = row.get('sr no')
            for col_name, schedule in row.items():
                if str(col_name).isdigit():
                    try:
                        day = int(col_name)
                        date = datetime.date(year, month, day)
                        Roster.objects.update_or_create(
                            name=name,
                            date=date,
                            defaults={'team': team, 'schedule': schedule}
                        )
                    except ValueError:
                        continue

    def _process_attendance_data(self, df):
        df.replace({np.nan: None}, inplace=True)
        for _, row in df.iterrows():
            attendance_date = row['parsed_date']

            defaults = {
                'employee_id': row['ads_id'],
                'user_type': row['user_type'],
                'designation': row['designation'],
                'department': row['department'],
                'location': row['location'],
                'first_in': to_safe_time(row['first_in']),
                'last_out': to_safe_time(row['last_out']),
                'gross_time': to_safe_time(row['gross_time']),
                'out_of_office_time': to_safe_time(row['out_of_office_time']),
                'out_of_office_count': row['out_of_office_count'],
                'net_office_time': to_safe_time(row['net_office_time'])
            }

            Attendance.objects.update_or_create(
                name=row['name'],
                date=attendance_date,
                defaults=defaults
            )


class SearchView(APIView):
    def get(self, request, *args, **kwargs):
        auth_error = validate_auth(request)
        if auth_error:
            return auth_error
        action = request.query_params.get('action')
        if action == 'count':
            return self._perform_count(request)
        elif action == 'low_hours':
            return self._find_low_hours(request)
        elif action == 'non_pl_low_hours':
            return self._find_non_pl_low_hours(request)
        elif action == 'wo_high_hours':
            return self._find_wo_high_hours(request)
        elif action == 'get_months':
            return self._get_available_months(request)
        elif action == 'get_valid_dates':
            return self._get_valid_dates(request)
        elif action == 'get_teams':
            return self._get_teams(request)
        elif action == 'get_shifts':
            return self._get_shifts(request)
        else:
            return self._perform_search(request)

    def _get_shifts(self, request):
        shifts = Roster.objects.values_list('schedule', flat=True).distinct().order_by('schedule')
        clean_shifts = [s for s in shifts if s]
        return Response(clean_shifts)

    def _get_teams(self, request):
        teams = Roster.objects.values_list('team', flat=True).distinct().order_by('team')
        clean_teams = [t for t in teams if t]
        return Response(clean_teams)

    def _get_available_months(self, request):
        months = Attendance.objects.dates('date', 'month', order='DESC')
        formatted_months = [m.strftime('%B %Y') for m in months]
        return Response(formatted_months)

    def _get_valid_dates(self, request):
        valid_dates = Attendance.objects.values_list('date', flat=True).distinct().order_by('date')
        date_list = [d.strftime('%Y-%m-%d') for d in valid_dates]
        return Response(date_list)

    def _get_date_range(self, request):
        start_date_str = request.query_params.get('start_date')
        end_date_str = request.query_params.get('end_date')

        if start_date_str:
            if not any(char.isdigit() for char in str(start_date_str)):
                 current_year = datetime.datetime.now().year
                 safe_date_str = f"{start_date_str} {current_year}"

                 start_date = pd.to_datetime(safe_date_str).date().replace(day=1)

                 next_month = start_date.replace(day=28) + datetime.timedelta(days=4)
                 end_date = next_month - datetime.timedelta(days=next_month.day)
            else:
                 start_date = pd.to_datetime(start_date_str).date()
                 end_date = pd.to_datetime(end_date_str).date() if end_date_str else start_date
        else:
            last_attendance = Attendance.objects.order_by('-date').first()

            if not last_attendance:
                return None, None
            target_date = last_attendance.date
            start_date = target_date.replace(day=1)
            next_month = start_date.replace(day=28) + datetime.timedelta(days=4)
            end_date = next_month - datetime.timedelta(days=next_month.day)

        return start_date, end_date

    def _perform_count(self, request):
        query = request.query_params.get('q')
        employee_id = request.query_params.get('id')

        if not query and not employee_id:
            return Response([])

        start_date, end_date = self._get_date_range(request)
        if not start_date:
            return Response({'error': 'No data found for the requested period.'}, status=status.HTTP_404_NOT_FOUND)

        rosters_query = Roster.objects.filter(date__range=[start_date, end_date])
        employee_names = []

        if employee_id:
            employee_names = Attendance.objects.filter(
                employee_id__iexact=employee_id,
                date__range=[start_date, end_date]
            ).values_list('name', flat=True).distinct()
            if not employee_names.exists():
                return Response({'error': f'No employee found with ID "{employee_id}"'})
        elif query:
            temp_rosters = rosters_query
            query_words = query.split()
            for word in query_words:
                temp_rosters = temp_rosters.filter(name__icontains=word)
            employee_names = temp_rosters.values_list('name', flat=True).distinct()
            if not employee_names.exists():
                 return Response([])

        results = []
        WFO_SCHEDULES = {'WFO-M', 'WFO-G', 'WFO-G2', 'WFO-S', 'WFO-N'}
        WFH_SCHEDULES = {'WFH-M', 'WFH-G', 'WFH-G2', 'WFH-S', 'WFH-N'}

        for name in employee_names:
            counts = {
                'Total WFO': 0, 'Total WFH': 0, 'Total WO': 0, 'Total PL': 0,
            }

            # Filter the main roster query for the specific name
            employee_rosters = rosters_query.filter(name=name)

            for entry in employee_rosters:
                schedule = str(entry.schedule).upper() if entry.schedule else ""
                if schedule in WFO_SCHEDULES:
                    counts['Total WFO'] += 1
                elif schedule in WFH_SCHEDULES:
                    counts['Total WFH'] += 1
                elif schedule == 'WO':
                    counts['Total WO'] += 1
                elif schedule == 'PL':
                    counts['Total PL'] += 1

            counts['Total working days'] = counts['Total WFO'] + counts['Total WFH']
            counts['Total Leaves'] = counts['Total WO'] + counts['Total PL']

            # Fetch the employee ID for the response
            emp_id = Attendance.objects.filter(name=name).values_list('employee_id', flat=True).first()

            results.append({
                'employee': name,
                'employee_id': emp_id,
                'period_start': start_date.isoformat(),
                'period_end': end_date.isoformat(),
                'counts': counts
            })

        return Response(results)

    def _find_low_hours(self, request):
        start_date, end_date = self._get_date_range(request)
        if not start_date:
            return Response({'error': 'No data found.'}, status=404)

        eight_hours = datetime.time(8, 0)
        low_hour_attendances = Attendance.objects.filter(
            date__range=[start_date, end_date],
            net_office_time__lt=eight_hours
        ).order_by('date', 'name')

        query = request.query_params.get('q')
        if query:
            query_words = query.split()
            for word in query_words:
                low_hour_attendances = low_hour_attendances.filter(name__icontains=word)

        employee_id = request.query_params.get('id')
        if employee_id:
            low_hour_attendances = low_hour_attendances.filter(employee_id__iexact=employee_id)

        roster_query = Roster.objects.filter(
                date__range=[start_date, end_date],
                name__in=low_hour_attendances.values_list('name',flat=True)
        ).exclude(
            Q(schedule__iexact='PL') |
            Q(schedule__iexact='WO') |
            Q(schedule__iexact='WFO-N')
        )

        team_name = request.query_params.get('teamname')
        if team_name:
            roster_query = roster_query.filter(team__iexact=team_name)

        shift_val = request.query_params.get('shift')
        if shift_val:
            roster_query = roster_query.filter(schedule__iexact=shift_val)

        roster_map = {
            (r.name, r.date): r
            for r in roster_query
         }


        results = []
        for att in low_hour_attendances:
            roster_record = roster_map.get((att.name, att.date))
            if roster_record:
                is_compliant = '❌'
                if att.net_office_time and att.net_office_time >= eight_hours:
                    is_compliant = '✅'

                results.append({
                    'name': att.name,
                    'employee_id': att.employee_id,
                    'team': roster_record.team,
                    'date': att.date,
                    'shift': roster_record.schedule,
                    'net_office_time': att.net_office_time,
                    'status': is_compliant
                })

        return Response({'count': len(results), 'employees_with_low_hours': results})

    def _find_non_pl_low_hours(self, request):
        start_date, end_date = self._get_date_range(request)
        if not start_date:
            return Response({'error': 'No data found.'}, status=404)

        eight_hours = datetime.time(8, 0)
        low_hour_attendances = Attendance.objects.filter(
            date__range=[start_date, end_date],
            net_office_time__lt=eight_hours
        ).order_by('date', 'name')

        roster_map = {
            (r.name, r.date): r
            for r in Roster.objects.filter(
                date__range=[start_date, end_date],
                name__in=low_hour_attendances.values_list('name', flat=True)
            ).exclude(schedule__iexact='PL')
        }

        results = []
        for att in low_hour_attendances:
            roster_record = roster_map.get((att.name, att.date))
            if roster_record:
                results.append({
                    'name': att.name,
                    'employee_id': att.employee_id,
                    'team': roster_record.team,
                    'date': att.date,
                    'shift': roster_record.schedule,
                    'net_office_time': att.net_office_time
                })

        return Response({'count': len(results), 'employees': results})

    def _find_wo_high_hours(self, request):
        start_date, end_date = self._get_date_range(request)
        if not start_date:
            return Response({'error': 'No data found.'}, status=404)

        eight_hours = datetime.time(8, 0)

        high_att_query = Attendance.objects.filter(
            date__range=[start_date, end_date],
            net_office_time__gt=eight_hours
        ).order_by('date', 'name')

        roster_map = {
            (r.name, r.date): r
            for r in Roster.objects.filter(
                date__range=[start_date, end_date],
                name__in=high_att_query.values_list('name', flat=True),
                schedule__iexact='WO'
            )
        }

        results = []
        for att in high_att_query:
            roster_record = roster_map.get((att.name, att.date))
            if roster_record:
                results.append({
                    'name': att.name,
                    'employee_id': att.employee_id,
                    'team': roster_record.team,
                    'date': att.date,
                    'schedule': roster_record.schedule,
                    'net_office_time': att.net_office_time
                })

        return Response({'count': len(results), 'data': results})

    def _perform_search(self, request):
        teamname = request.query_params.get('teamname')
        query = request.query_params.get('q')
        shift = request.query_params.get('shift')
        employee_id = request.query_params.get('id')

        start_date, end_date = self._get_date_range(request)
        if not start_date:
            return Response({'error': 'No data found for the requested period.'}, status=status.HTTP_404_NOT_FOUND)

        rosters = Roster.objects.filter(date__range=[start_date, end_date])

        if employee_id:
            names_with_id = Attendance.objects.filter(
                employee_id__iexact=employee_id,
                date__range=[start_date, end_date]
            ).values_list('name', flat=True).distinct()
            if not names_with_id.exists():
                return Response([])
            rosters = rosters.filter(name__in=names_with_id)
        if teamname:
            rosters = rosters.filter(team__icontains=teamname)
        if query:
            query_words = query.split()
            for word in query_words:
                rosters = rosters.filter(name__icontains=word)
        if shift:
            rosters = rosters.filter(schedule__iexact=shift)

        rosters = rosters.order_by('date', 'name')

        names_to_fetch = rosters.values_list('name', flat=True).distinct()
        attendance_records = Attendance.objects.filter(
            name__in=rosters.values_list('name', flat=True),
            date__range=[start_date, end_date]
        )

        att_map = {}
        for att in attendance_records:
            att_map[(att.name, att.date)] = {
                'first_in': att.first_in,
                'last_out': att.last_out,
                'net_office_time': att.net_office_time
            }

        eight_hours = datetime.time(8, 0)
        results = []

        roster_data = rosters.values('id', 'name', 'date', 'schedule', 'team')

        annotation_map = {
            ann.roster_id: ann
            for ann in RosterAnnotation.objects.filter(roster__in=rosters)
        }

        results = []

        for r in roster_data:
            r_id = r['id']
            r_name = r['name']
            r_date = r['date']

            att_data = att_map.get((r_name, r_date))

            first_in = None
            last_out = None
            net_time = None
            system_status = '❌'

            if att_data:
                first_in = att_data['first_in']
                last_out = att_data['last_out']
                net_time = att_data['net_office_time']

            current_schedule = str(r['schedule']).strip().upper() if r['schedule'] else ""

            if current_schedule in ['WO', 'PL', 'CO']:
                system_status = '✅'

            elif current_schedule == 'WFO-N' and first_in and first_in >= datetime.time(21, 0):
                system_status = '✅'

            elif net_time and net_time >= eight_hours:
                system_status = '✅'

            annotation = annotation_map.get(r_id)

            comment_val = annotation.comment if annotation else ""

            if annotation and annotation.manual_status:
                final_status = annotation.manual_status
            else:
                final_status = system_status

            results.append({
                'id': r_id,
                'name': r_name,
                'team': r['team'],
                'date': r_date,
                'schedule': r['schedule'],
                'comment': comment_val,
                'attendance': {
                    'first_in': first_in,
                    'last_out': last_out,
                    'net_office_time': net_time,
                    'status': final_status
                }
            })

        return Response(results)

class UpdateAnnotationView(APIView):
    def post(self, request):
        auth_error = validate_auth(request)
        if auth_error:
            return auth_error
        roster_id = request.data.get('roster_id')
        comment = request.data.get('comment')
        status_val = request.data.get('status')

        if not roster_id:
            return Response({'error': 'Roster ID is required'}, status=400)

        try:
            roster_obj = Roster.objects.get(id=roster_id)

            RosterAnnotation.objects.update_or_create(
                roster=roster_obj,
                defaults={
                    'comment': comment,
                    'manual_status': status_val
                }
            )
            return Response({'message': 'Update successfully'})

        except Roster.DoesNotExist:
            return Response({'error': 'Roster entry not found'}, status=404)
        except Exception as e:
            return Response({'error': str(e)}, status=500)
