// Key changes needed in your Chatbot.jsx:

// 1. Update the option click handler to properly handle "swagger/workload"
const handleOptionClick = async (optionText) => {
  // Clean the option text - remove numbering and extra spaces
  const cleanedOpt = optionText
    .replace(/^\d+\.|[a-zA-Z]\.\s*/, "")
    .trim()
    .toLowerCase();

  const userMessage = {
    id: Date.now(),
    text: cleanedOpt,
    sender: "user",
    time: getCurrentTime(),
  };

  setMessages((prev) => [...prev, userMessage]);
  setFormDisabled(true);
  setIsTyping(true);

  try {
    setApiTimeout(() => {});
    const res = await postMessage(cleanedOpt);
    clearCurrentTimeout();

    const latest = res.data.chat_history?.slice(-1)[0];
    if (latest) {
      const botResponse = {
        id: Date.now(),
        text: latest.message || "",
        sender: "bot",
        time: getCurrentTime(),
        options: latest.options || [],
      };

      // Check if response contains form fields
      if (hasFormFields(latest)) {
        botResponse.formFields = extractFormFields(latest, {});
        botResponse.isFormMessage = true;
        
        // Auto-detect workload form and set it up
        const formType = determineFormType(botResponse.formFields);
        if (formType === 'workload') {
          setCurrentFormType(formType);
          setCurrentFormFields(botResponse.formFields);
          // Optionally auto-open the form
          // setActiveForm(botResponse.formFields);
        }
      }

      setMessages((prev) => [...prev, botResponse]);
      setFormDisabled(!checkEnableForm(botResponse.text));
    }
  } catch (error) {
    clearCurrentTimeout();
    console.error("Error in option click:", error);
  }

  setIsTyping(false);
};

// 2. Ensure the service field properly triggers cascading updates
const handleServiceInputChange = async (value) => {
  setServiceInputValue(value);
  setFormData(prev => ({ ...prev, service: value }));
  if (errors.service) setErrors(prev => ({ ...prev, service: null }));
  
  // Reset dependent fields when service changes
  if (!value.trim()) {
    setServiceTypeInfo({ isApplication: false, serviceOption: null });
    setShowServiceDropdown(false);
    return;
  }

  // Show dropdown when minimum characters are met
  if (value.trim().length >= 4) {
    setShowServiceDropdown(true);
    if (onFieldChange) {
      let updated = { ...formData, service: value };
      updated = applyCascadingLogic(updated, 'service');
      setFormData(updated);

      const filtered = filterNonEmptyFields(updated);
      await onFieldChange(filtered, 'service');
    }
    
    // Keep focus on input after async operation
    setTimeout(() => {
      serviceInputRef.current?.focus();
    }, 0);
  } else {
    setShowServiceDropdown(false);
  }
};

// 3. Handle swagger download with proper error handling
const handleDownloadSwagger = async () => {
  const { server, eg, service } = formData;

  // Check if it's an application type
  if (serviceTypeInfo.isApplication) {
    alert("Swagger file doesn't exist for applications. Only REST APIs have swagger specifications.");
    return;
  }

  // Validate required fields
  if (!server || !eg || !service) {
    alert("Please fill all required fields (Service, Layer, Server, and EG) before downloading.");
    return;
  }

  try {
    setIsSubmitting(true);
    
    const response = await downloadSwagger({ 
      server, 
      egName: eg, 
      apiName: service 
    });

    // Clean and format the swagger JSON
    const cleanedSwaggerJson = cleanSwaggerJson(response);

    // Enhance swagger with metadata
    if (cleanedSwaggerJson && typeof cleanedSwaggerJson === 'object') {
      if (!cleanedSwaggerJson.info) {
        cleanedSwaggerJson.info = {};
      }
      
      if (!cleanedSwaggerJson.info.title || cleanedSwaggerJson.info.title === 'API Documentation') {
        cleanedSwaggerJson.info.title = `${service} API Documentation`;
      }
      
      if (!cleanedSwaggerJson.host && server) {
        cleanedSwaggerJson.host = server;
      }
      
      // Add download metadata
      cleanedSwaggerJson.info['x-download-info'] = {
        service: service,
        server: server,
        eg: eg,
        downloadDate: new Date().toISOString()
      };
    }

    // Create formatted JSON
    const formattedJson = JSON.stringify(cleanedSwaggerJson, null, 2);

    // Download the file
    const blob = new Blob([formattedJson], {
      type: "application/json;charset=utf-8"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${service}-swagger-spec.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    console.log(`âœ… Successfully downloaded Swagger specification for ${service}`);
    
    // Show success message to user
    alert(`Successfully downloaded swagger specification for ${service}`);

    // Clear the form session after successful download
    if (clearFormSession) {
      clearFormSession();
    }

  } catch (err) {
    console.error("Swagger download error:", err);
    alert(`Failed to download Swagger file: ${err.message || 'Unknown error'}`);

    // Clear the form session after error
    if (clearFormSession) {
      clearFormSession();
    }
  } finally {
    setIsSubmitting(false);
  }
};

// 4. Enhanced form type detection for swagger/workload
const determineFormType = (fields) => {
  const fieldNames = fields.map(f => f.name.toLowerCase());
  
  // Check for swagger/workload form structure
  const hasServiceField = fieldNames.includes('service');
  const hasLayerField = fieldNames.includes('layer');
  const hasServerField = fieldNames.includes('server');
  const hasEgField = fieldNames.includes('eg');
  
  // If it has all workload fields, it's a workload form
  if (hasServiceField && hasLayerField && hasServerField && hasEgField) {
    return 'workload';
  }

  // Check for filter forms
  const isFilterForm = fields.some(field =>
    field.name.toLowerCase().includes('filter') &&
    Array.isArray(field.options)
  );
  
  if (isFilterForm) return 'filter';

  // Check for multiple field forms with expiry/created
  const hasExpiryOrCreatedField = fields.some(field =>
    field.name.toLowerCase().includes('expiry') ||
    field.name.toLowerCase().includes('created')
  );
  
  if (hasExpiryOrCreatedField) return 'multiple';
  
  return 'default';
};

// 5. Ensure proper message formatting for workload submission
const formatFormDataToSentence = (formData, originalFields, formType = null) => {
  if (!formData || Object.keys(formData).length === 0) {
    return "No form data provided";
  }
  
  const sentences = [];
  const fieldLabelsMap = {};
  
  if (originalFields) {
    originalFields.forEach(field => {
      fieldLabelsMap[field.name] = field.label || field.name;
    });
  }
  
  if (formType === 'workload') {
    // Special formatting for workload submissions
    Object.entries(formData).forEach(([key, value]) => {
      if (value !== null && value !== undefined && value !== '') {
        const fieldLabel = fieldLabelsMap[key] || key;
        const formattedLabel = fieldLabel.replace('* ', '').charAt(0).toUpperCase() + 
                              fieldLabel.replace('* ', '').slice(1);
        sentences.push(`${formattedLabel}: "${value}"`);
      }
    });
  } else {
    Object.entries(formData).forEach(([key, value]) => {
      if (value !== null && value !== undefined && value !== '') {
        const fieldLabel = fieldLabelsMap[key] || key;
        const formattedLabel = fieldLabel.charAt(0).toUpperCase() + fieldLabel.slice(1);
        sentences.push(`${formattedLabel}: "${value}"`);
      }
    });
  }
  
  return sentences.length > 0 ? sentences.join(', ') : "No values provided";
};

// 6. Add visual feedback for form state
// Add this CSS to your Chatbot.css:
/*
.dynamic-form-container {
  background: #f9f9f9;
  border-radius: 8px;
  padding: 16px;
  margin: 12px 0;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.download-swagger-button:disabled {
  background: #ccc !important;
  cursor: not-allowed !important;
  opacity: 0.6;
}

.download-swagger-button:not(:disabled):hover {
  background: #0056b3;
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(0,123,255,0.3);
}

.service-field-container {
  position: relative;
}

.service-dropdown {
  animation: slideDown 0.2s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.form-field.error .form-input,
.form-field.error .form-select {
  border-color: #dc3545;
}

.error-message {
  color: #dc3545;
  font-size: 12px;
  margin-top: 4px;
  display: block;
}

.form-actions {
  display: flex;
  gap: 8px;
  margin-top: 16px;
  flex-wrap: wrap;
}
*/
